(import-for-syntax (srfi 1)
                   (srfi 13)
                   (chicken format)
                   (chicken foreign)
                   (chicken string))

(import (only (rename scheme (make-rectangular %make-rectangular)) %make-rectangular))

(define-syntax complex-foreign-lambda
  (ir-macro-transformer
   (lambda (e i c)
     (define (conc* . args)
       (string->symbol
        (apply conc args)))
     (let* ((ret-type (strip-syntax (cadr e)))
            (fn (caddr e))
            (args (cdddr e))
            (named-args
             (let loop ((a args)
                        (i 0))
               (if (null? a)
                   '()
                   (let ((arg (car a)))
                     (cons
                      (cons (if (and (pair? arg) (eq? (strip-syntax (car arg)) 'complex))
                                (conc* 'z i)
                                (conc* 'x i))
                            (if  (pair? arg)
                                 (map strip-syntax arg)
                                 (strip-syntax arg)))
                      (loop (cdr a) (+ i 1))))))))
       (define (make-letvars named-args)
         (let ((only-complex (filter (lambda (x)
                                       (and (pair? (cdr x))
                                            (eq? 'complex (cadr x))))
                                     named-args)))
           (append-map (lambda (x)
                         `((,(conc* 'r (car x)) (real-part ,(car x)))
                           (,(conc* 'i (car x)) (imag-part ,(car x)))))
                       only-complex)))
       (define (make-foreign-args named-args)
         (append-map (lambda (x)
                       (if (and (pair? (cdr x)) (eq? (cadr x) 'complex))
                           `((,(caddr x) ,(conc* 'r (car x)))
                             (,(caddr x) ,(conc* 'i (car x))))
                           `((,(cdr x) ,(car x)))))
                     named-args))
       (define (make-inits named-args)
         (let* ((only-complex (filter (lambda (x)
                                        (and (pair? (cdr x))
                                             (eq? 'complex (cadr x))))
                                      named-args)))
           (fold (lambda (x y)
                   (cons
                    (let ((name (car x))
                          (type (caddr x)))
                      (format "gsl_complex~a ~a; \nGSL_SET_COMPLEX(&~a,~a,~a);"
                              (if (eq? type 'double)
                                  ""
                                  (conc "_" type))
                              (symbol->string name)
                              (symbol->string name)
                              (conc "r" name)
                              (conc "i" name)))
                    y))
                 '()
                 only-complex)))
       (define (make-return ret-type fn named-args)
         (let ((strargs (string-join (map (lambda (x)
                                            (symbol->string (car x)))
                                          named-args) ",")))
           (cond ((and (pair? ret-type)
                       (eq? 'complex (car ret-type)))
                  `(,(format "gsl_complex~a out = ~a(~a);"
                             (if (eq? (cadr ret-type) 'double)
                                 ""
                                 (conc "_" (cadr ret-type)))
                             fn strargs)
                    ,(format "C_return(scheme_make_rect(GSL_REAL(out),GSL_IMAG(out)));")))
                 ((eq? ret-type 'void)
                  `(,(format "~a(~a);" fn strargs)))
                 (else `(,(format "C_return(~a(~a));" fn strargs))))))
       (let* ((foreign-args (make-foreign-args named-args))
              (letvars (make-letvars named-args))
              (inits (make-inits named-args))
              (return (make-return ret-type fn named-args))
              (return-type (if (and (pair? ret-type)
                                    (eq? (car ret-type) 'complex))
                               'scheme-object
                               (strip-syntax (cadr e)))))
         (if (null? letvars)
             `(foreign-safe-lambda* ,return-type ,foreign-args
                ,@inits
                ,@return)
             `(lambda ,(map car named-args)
                (let ,letvars
                  ((foreign-safe-lambda* ,return-type ,foreign-args
                     ,@inits
                     ,@return)
                   ,@(map cadr foreign-args))))))))))
